#summary Roadmap
#labels Featured,Phase-Implementation

=Introduction=

This page contains Fog-Framework roadmap and goals, editable by project members. Initial items were copied from project TODO.

There are many libraries for computer graphics and GUI development.. Each developer that want to create an application with user interface or visualization must choose set of libraries that will be used to do the job. Today's computers are so powerful and difference between slow and fast code is day by day smaller. This is reason why some libraries are terrible slow and there is nobody working on optimizations.

Fog-Framework is different. When library was in designing state (currently it still is) the main and most important requirement was performance, integration and easy-of-use API. This is reason why Fog-Framework contains many classes not strictly related to computer graphics. Low-level stuff is usually not exported so developers using Fog-Framework are using high-level classes resulting in excellent performance.

=Framework Libraries=

Fog-Framework currently contains these libraries:

  * Fog-Core - Platform abstraction and tools.
  * Fog-G2d - 2d graphics API.
  * Fog-UI - UI toolkit.
  * Fog-Svg - SVG DOM, parser and renderer.
  * Fog-Xml - XML DOM, parser and writer.

=Design Notes=

Fog-Framework design notes (in points):

 * Library depends only to libraries that are installed on target operating system by default.
   * Under Windows only WinAPI is used (other libraries like libpng can be used too, but you must first install them and enable them by build system).
   * Under Linux/BSD/MAC only freetype2, libjpeg and libpng libraries are needed (and libjpeg and libpng support can be disabled). By default Fog also tries to use fontconfig.
 * Do not use C++ stl library.
 * Do not use C++ RTTI (no dynamic casts) and C++ exceptions.
 * Critical code should support modern CPU extensions (MMX, SSE2).
 * Do not depend to X11 under Linux/BSD unless static linking is enabled.

=TODO - Legend=

{{{
( ) Incomplete
(w) Working
}}}

=TODO - Fog-Core=

  * Container refactorization
    * ( ) Rewrite containers in the following way, each container needs to have two variants - implicitly shared and non-shared.
    * ( ) Add possibility to any container to use statically based temporary storage, but simplify the design of these classes.
    * ( ) Introduce `Map<>`.
    * ( ) Introduce `HashSet<>`
    * ( ) Introduce `MapSet<>`
    * ( ) Introduce hash table that is able to use custom accessor in get / put / contains methods. See FontManager.cpp TODO entry.
    * ( ) Add ability to use owned-containers (no implicit sharing) to List / Hash.

  * Object and MetaClass:
    * ( ) `Fog::Object` memory management should be hierarchy based. Allow adding Objects to Object, Widget will use different storage for added widgets. Introduce ChildEvent in `Fog::Object`.
    * ( ) `Fog::Component` should be created and hierarchy based, make `Fog::Object` as lightweight as possible, because it might be used in many places in the future.

  * String:
    * ( ) Use SSE2/SSSE3 optimized functions in string.
    * ( ) `Fog::RegExp` - use TRex
    * ( ) `Fog::String`/`Fog::Locale` - add support for group separators
    * ( ) `Temporary...<N>::free` sometimes not frees the memory? Investigate and remove this.

  * Streaming:
    * ( ) Text Streams (using `TextCodec`), including `err()`, `out()` and `in()`

  * Error framework:
    * ( ) Error framework that can translate ERR messages into string so we can display them.
    * ( ) Create some script which can extract names from header files and which can produce the error msg table.

  * Logging framework:
    * ( ) Make minimalist and extensible logging framework, sometimes it's really needed to write something somewhere, but current API is not supporting it

=TODO - Fog-Graphics=

  * Painter and RasterEngine:
    * ( ) Ability to paint to A8 surface
    * ( ) Text transform
    * ( ) Text over path
    * Gradients
      * (w) Better quality settings (low should use current algorithm, normal should use bilinear filtering and high should use bilinear filtering and super-sampling)
    * (w) High-quality downscaling (transformation / scaling down)
      * ( ) Write MMX version
      * ( ) Write SSE2 version
      * ( ) Use in painter when suitable
    * ( ) Glyph rendering must be two pass based
      * ( ) Apply glyph metrics, advance, etc, serialize to X, Y, `ImageData` array
      * ( ) Render using not `GlyphSet`, but `ImageSet`.
    * ( ) Compositing operators
      * ( ) ColorBurn (SVG operator)
      * ( ) ColorDodge (SVG operator)
      * ( ) HardLight (SVG operator)
      * ( ) SoftLight (SVG operator)
      * ( ) Overlay (SVG operator)
      * ( ) Operator plugins (shaders and C++)
      * ( ) Write some basic C/MMX/SSE2 composite functions for ARGB32
      * ( ) Write MMX composite functions for XRGB32 and PRGB32
      * ( ) Write C composite functions for A8
      * ( ) Write MMX composite functions for A8
      * ( ) Write SSE2 composite functions for A8
    * ( ) Implement ARGB (LCD) path rasterizer.

  * Font and Text Rendering:
    * ( ) Work on fonts and typography
    * ( ) Cache size control
    * ( ) Increase granularity of X position in glyphs to 3 (0.00, 0.33, 0.66), because vector fonts can be very sensitive in small sizes.
    * ( ) Text Iterator, retrieving glyph metrics, text metrics, individual glyphs and glyph sets.

  * Path and Vector Processing:
    * ( ) PathToRegion
    * ( ) RegionToPath (current implementation simply adds rectangles from region, do we need something better?
    * ( ) Add `addText()` to path
    * ( ) What about warp?

  * Color Utilities / Conversion:
    * ( ) Add basic compositing also to Argb so we can use some color transformations when drawing widgets.

  * Image / filtering:
    * ( ) Image filters (Blur, Sharpen, ...) should be grouped and result should be `ImageFilter` class that will be able to do any image based transformations.
    * ( ) Each effect should contain opacity value that will define blend factor of modified image into source image (this can be used by UI animations).
    * ( ) Blur
    * ( ) ColorMatrix
    * ( ) ComponentTransfer
    * ( ) Sharpen
    * ( ) Convolve
    * ( ) Add new image resampler (scale)
    * ( ) Redesign Image::scale(), use ROI concept

  * Image IO:
    * ( ) Fix ICO reader (BMP / PNG)
    * ( ) Add ICO writer (BMP / PNG)
    * ( ) Add GIF writer, rewrite GIF support
    * ( ) Fix BMP transparency detection (impossible?)

  * Geometry:
    * ( ) Curve-to-curve stroking
    * ( ) Curve dashing
    * ( ) Path stroke cache (not path stroke, but path curve properties, like length, inflection points, etc...)
    * ( ) Add more path mixing methods PathF::addPath(const PathD& other) and other (simpler api)
    * ( ) TransformD should allow transformation of single-precision (F) data

=TODO - Fog-Xml=

  * XML Core:
    * (w) XmlWriter

=TODO - Fog-Svg=

  * SVG Core:
    * ( ) Default color in Svg gradient should be 0.0:black, 1.0:white if no stops are provided

=TODO - Fog-UI=

  * New vector UI framework (Canvas)
    * ( ) Define the canvas API and completely delete the raster based UI.
    * ( ) ...

  * Top level window management:
    * (w) perhaps ability to create nonrect-windows, too
    * (w) modal windows support
    * ( ) ability to provide a way to draw own frame/caption (complete themeable)
    * ( ) ability to use directdraw/opengl as a backend (with flipping backend handler!)
    * ( ) also some grouping methods for multiwindow-system would be cool.

  * Animation Support:
    * (w) introduce simple animation support to Fog. 
    * (w) possible to add fixed time animations (e.g. 200ms)
    * (w) possible to add fixed step animations (e.g. 20 Steps)
    * (w) add animation parameter to different widget-methods (show,hide,opacity...)

  * Layout Core:
    * (w) First define the API, what layout will do, what is expected that widget can calculate, how algorithms will be used to set / reset / recalculate the layout.
    * ( ) Purpose of LayoutEvent
    * ( ) CanvasLayout
    * (x) FlowLayout
    * (x) HBoxLayout/VBoxLayout
    * (x) GridLayout
    * ( ) DockLayout

  * Widgets Low Level Management (DoubleBuffer, Clipping):
    * ( ) Make possibility to set transparent region in widget (not really transparent, but region where the background must be used first). Introduce `Widget::getPaintMode()`, `Widget::getBackgroundRegion()`.
    * ( ) Double buffering of child widgets (transparency, animations, effects).
    * ( ) Some widgets need to store background in separate buffer (Image).
    * ( ) Add client rectangle to the window (this is really needed, I though that it's not).
    * ( ) Each widget will contain widgets in client rectangle and hidden widgets outside of it (for scrollbars, list/grid headers, footers, etc).

  * Widgets Core:
    * ( ) Widget updating process is too complex, simplify it or document why it's complex. Is recursive alternative good to switch? (Petr, Stefan)

  * Theming:
    * ( ) What theming model to use. Currently the Windows-Theming-Model will be probably used with few extensions / additions.
    * ( ) Drawing themed component shouldn't depend to component instance.
    * ( ) Theming should be state based, animations must be possible.
    * ( ) Theme switch must be allowed.
    * ( ) Using different themes in the application should be possible by simply calling myWidget->setTheme(theme).
    * ( ) Theme may define also fonts, but the behavior should be configurable. For example I like themes, but I like to keeping my font settings for each. This means that the Widget::getFont() and Widget::setFont() family methods should be extended. For example introducing Widget::getThemeFont() / Widget::getActiveFont() methods ?

=TODO - Refactorization, Ideas=

  * ( ) `Fog::RasterPaintEngine` - Use binary search to find first region if complex clipping is used.
  * (w) All getters (`get()` methods) should be declared before setters (`set()` methods)
  * (w) Make sure that all classes are using correct `getXXX()` methods
  * (w) Some methods named `clear()` should be renamed to `reset()`, audit this (this not applies to containers, strings, etc...)
  * (w) All enums and constants should be `UPPERCASED`.

=Concepts and Discussion=

New concepts / discussion here.