#summary How to write code for Fog-Framework.
#labels Phase-Implementation

=Identation, Braces, Position of Keywords=

*Code Indentation*: Code inside `{}` braces should be indented for 2 whitespaces except for class visibilty (`public`, `private` etc) and `goto` labels. Do not use tabs! 

*Braces* should always have there own line, for example: 
{{{
struct SomeStruct
{
  struct Node
  {
    // some code here
  };
};
}}}

If the statement inside a loop or an `if`-statement merely consists of one line, it should be all written in the same line.  

*Control keywords* like `if`, `for`, `while` are always followed by a single whitespace.

{{{
if (object.isNull()) return ERR_SOMETHING;

for (;;)
{
  // do something infinite here
}
}}}

The *`const` keyword* should always appear before the value type, for example:  
{{{
const Char* s = string->getData();
}}}

The *`&` / `*` indicating a reference / pointer type* should always appear immidiatly behind the value type:
{{{
EventLoop* createEventLoop(const String& type);
}}}

*Passing parameters*: Instead of passing values to function, you should prefer a constant reference if the value‘s type is bigger than 4-8 bytes or it's not POD type. 
{{{
EventLoop* createEventLoop(const String& type);
EventLoop* createEventLoop(String type); //< This is bad.
}}}
  
But nevertheless:  
{{{
err_t setInt(int32_t n, int base); 
err_t setInt(const int32_t& n, const int& base); //< This is bad
}}}   

Notice that for example `Argb` is always passed as value, because it's just `uint32_t` wrapped in a structure, but `ArgbStop` is always passed as reference (it's primitive type, but it's too long to pass it as value).  

Use `struct` instead of `class`.  


=Comments=

Comments should always start with a `//`. 

*Doxygen* is used by Fog-Framework in order to document the source code. Doxygen comments should look like `//!`. Now, doxygen markups (e.g. `@verbatim`) can be used. For more information see the Doxygen documentation. 

There should be standard *file comment* at the top of each file: 
{{{
// [Fog-<MODULE> Library - C++ API]
//
// [License] 
// MIT, See COPYING file in package
}}}
Always also insert copyright notices if you use other open source code.

If you want to add *personal comment* to code (for example TODO, FIXME, etc) use standard uppercased form. If you want to add your name to it, use brackets. Example:
{{{
// TODO(Petr): This code not works and will be fixed after 
// feature X is implemented.

...

// FIXME(Petr): MMX code broken.
}}}

In order to *name sections* of code, what should actually be done very often, write the comments in formation `// [SECTION_TITLE]`. For example:
{{{
// [Guard]
#ifndef _FOG_CORE_AUTOLOCK_H
#define _FOG_CORE_AUTOLOCK_H

// [Dependencies]
#include <Fog/Build/Build.h>

#include <Fog/Core/Assert.h>
#include <Fog/Core/Atomic.h>
#include <Fog/Core/Lock.h>
}}}
  
=Naming Conventions=

*C++ source files* always end with `.cpp`. Headers end with `.h`. Both are always starting with an upper case letter and use camel case notation, for example:  
{{{
SomeClass.h
SomeClass.cpp
}}}

All headers should start with an *include guard*, in order to prevent multiple inclusion. It should be in the format `_<PROJECT>_<MODULE>_<FILE>_H`, for example: 
{{{
// [Guard]
#ifndef _FOG_MODULE_SOMECLASS_H
#define _FOG_MODULE_SOMECLASS_H

...

#endif // _FOG_MODULE_SOMECLASS_H
}}}

Everything, which belongs the Fog has to be declared inside the *Fog namespace*, but there are some typedefs which are not. For example Fog system types `sysint_t` and `sysuint_t` thats used similarly as `size_t` and `ssize_t` are declared inside global namespace. The `err_t` type is also declared in global namespace.   


*Structs* start with an uppercase letter and use camel case notation, for example:
{{{
struct (FOG_API) SomeClass;
}}}

*Functions* start with a lowercase letter and use camel case notation, for example: 
{{{
FOG_INLINE void* allocMyObject(sysuint_t size);
}}}

*Macros* should always be uppercase. Every macro should start with a `FOG_`.

*Private member variables* always start with with a leading underscore, for example: 
{{{
private:
  //! @brief Pointer to locked mutex.
  Lock* _target;
}}}

Sometimes private variables are declared as public, but contains underscore. Reason is that there are many C functions inside Fog-Framework (for example C implementation, SSE2 implementation, etc...) and these functions need access to class members.

*Implementation* is always in .cpp file, except for inline methods which must be in headers. The convention is that everything that must be exported into shared library *must* be placed in the .cpp file. Everything that should be inlined and not exported should be in headers. Private classes are declared in header files containing `_p` suffix, for example `SomeClass_p.h` and implemented in standard `SomeClass.cpp` file. Private and non-exported classes must be declared using `FOG_HIDDEN` attribute.

=Inlining=

In order to inline functions, use the `FOG_INLINE` macro. Notice that `FOG_INLINE` macro expands to compiler dependent way how to tell compiler to always inline a given code. If you don't want to inline code, but you want to declare it in header (for example in template) use `FOG_NO_INLINE` macro.

=Parameter order=
If possible: first destination parameter, then source parameter. For example:
{{{
static void pathFromCGPath(ApplyInfo& dst, CGPathRef src);
}}}

=Error Handling=
Fog uses error codes in the form of `ERR_XXX`, e.g.  `ERR_OK` or `ERR_RT_OUT_OF_MEMORY`. They are defined in the `Constants.h` header.  

There is a nice macro which makes error handling easy: RETURN_ON_ERROR. 

Instead of
{{{
err_t err;

if ((err = result.set(Fog::Ascii8("Hello World"))) != Fog::ERR_OK) return err;
if ((err = result.append(Fog::Char('!'))) != Fog::ERR_OK) return err;

return Fog::ERR_OK;
}}}

You can write
{{{
RETURN_ON_ERROR( result.set(Fog::Ascii8("Hello World")) );
RETURN_ON_ERROR( result.append(Fog::Char('!')) );

return Fog::ERR_OK;
}}}
Use it!

Exceptions are forbidden to use (by `-fno-exceptions` flag). This has some advantages:
  *  Resulting binary size is bigger
  *  It's not needed to write exception-safe code.
  *  Error codes are lightweight and enough.

=Integer typedefs=

use standard C++ integer typedef as they are declared in the stdint header, which means:  

`int8_t` instead of `signed char`, <br>
`uint8_t` instead of `unsigned char`  

`int16_t` instead of `short`, <br>
`uint16_t` instead of `unsigned short`  

`sysint_t` instead of `int`, <br>
`sysuint_t` instead of `unsigned int`, <br>
(`sysint_t` decides between 32- and 64-bit)  

`sysint_t` and `sysuint_t` are Fog types that have same role as ssize_t and size_t types. They are used in places where you normally use size_t (string length, array length, ...).

=0, NULL etc.=

`0` is used for integers, `0.0` is used for reals, `NULL` is used for pointers, `\0` or `Char('\0')` is used for chars.

=Column length of files=

The column length should always be 80 characters. If your code uses many inlines and code is bigger (for example 90-100 characters), keep in in one line.

=Determine OS=

There are macros available, which can be used in order to determine the current operating system at compile-time.
These are in the format `FOG_OS_<PLATFORM>`. `PLATFORM` can be: `WINDOWS`, `POSIX`, `LINUX`, `FREEBSD`, `OPENBSD`, `NETBSD`, `HPUX` or `MAC`.  

Example:
{{{
#if defined(FOG_OS_WINDOWS)
// Windows code …
#elif defined(FOG_OS_MAC)
// Mac code …
#else
// POSIX code …
#endif
}}}

=Infinite Loops=

When using infinite loops, they should start with `for (;;)`.