#summary Performance of Fog vs. other libraries.
#labels Featured

=Introduction=

This page contains informations from Fog benchmark tool. Benchmarks are designed to check speed of:
  * Fog (singlethreaded and multithreaded)
  * GDI+
  * Cairo

Usually the benchmarks for Cairo are run under Linux, and bechmarks fog GDI+ under Windows. You can also try the benchmark by configuring fog using 'configure-bench' command. It will build 'bench' file that can be run to do the tests.

=Benchmark Tests=

  * FillRect - Test that will fill rectangles of 128x128 pixels. Rectangle fills are often optimized as special fastpaths, so this test will show how these special cases are optimized in library.
  * FillRound - Test that will fill rounded rectangles of 128x128 pixels and 8 radius. This test should be compared with FillRect and can tell the performance of rasterizing objects that are very similar to rectangles in size and in shape. It just reveals machinery and slowdown caused by library rasterizer.
  * FillPolygon - Test that will fill random polygons containing 10 vertices (coordinates can be generated for any point that is valid in destination image).
  * FillPattern - Filling 128x128 rectangle by linear or radial gradient brush. When filling we are interested in getting time consumed to create fill. This is reason that filling is also done in 128x128 rectangles.
  * BlitImage - Blitting image with SrcOver (Ported & Duff) operator. This test should show how blitting engine is optimized for your CPU. Image sizes are also 128x128 and contains alpha channel.

The tests are usually done to perform 100.000 operations and result is time in [ms] for each kind of operation. The (mt) comment in Fog tests means that multithreading is used for tests, the number of threads is always determined as number of CPUs (or cores). The size of destination image is usually 640x480 and pixel format is PRGB32 (premultiplied 32-bit format with alpha channel).

In the future there will be probably more tests. Current tests were designed to tune Fog library, not to compare with others (this is also reason for gradient fills, image blitting and other tests).

=Benchmark Results=
Summary could be found in [BenchmarkSummaryTable Summary Table]

==Intel Quad Q6600 4x2.4GHz, 8GB RAM, Gentoo Linux 64-bit (dev-cpu)==

{{{
Fog benchmark tool v0.1

Surface=640x480, Quantity=100000
Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.40GHz (MMX=yes, SSE=yes, SSE2=yes, SSE3=yes, cores=4)

Fog - FillRect - 2057.061 [ms]
Fog - FillRound - 3659.400 [ms]
Fog - FillPolygon - 33708.193 [ms]
Fog - FillPattern - LinearGradient - 2665.243 [ms]
Fog - FillPattern - RadialGradient - 6623.788 [ms]
Fog - BlitImage - 3948.032 [ms]

Fog - FillRect (mt) - 655.907 [ms]
Fog - FillRound (mt) - 1996.621 [ms]
Fog - FillPolygon (mt) - 13669.000 [ms]
Fog - FillPattern - LinearGradient (mt) - 771.105 [ms]
Fog - FillPattern - RadialGradient (mt) - 1918.720 [ms]
Fog - BlitImage (mt) - 1132.166 [ms]

Cairo - FillRect - 2152.900 [ms]
Cairo - FillRound - 14443.486 [ms]
Cairo - FillPolygon - 66757.446 [ms]
Cairo - FillPattern - LinearGradient - 24875.558 [ms]
Cairo - FillPattern - RadialGradient - 85403.838 [ms]
Cairo - BlitImage - 4039.170 [ms]

Summary:
Fog        - 52661.717 [ms]
Fog (mt)   - 20143.519 [ms]
Cairo      - 197672.398 [ms]
}}}

==Intel Xeon E5310 8x1.6GHz, 4GB RAM, Windows Vista 32-bit==

{{{
TODO: Need to run with new benchmark tool

Fog - FillRect - 3116,069 [ms]
Fog - FillRound - 6084,969 [ms]
Fog - FillPath - 41680,029 [ms]
Fog - FillPattern - LinearGradient - 7975,672 [ms]
Fog - FillPattern - RadialGradient - 12228,414 [ms]
Fog - BlitImage - 5792,178 [ms]

Fog - FillRect (mt) - 694,514 [ms]
Fog - FillRound (mt) - 4524,837 [ms]
Fog - FillPath (mt) - 26104,182 [ms]
Fog - FillPattern - LinearGradient (mt) - 1375,718 [ms]
Fog - FillPattern - RadialGradient (mt) - 1926,199 [ms]
Fog - BlitImage (mt) - 1091,912 [ms]

GdiPlus - FillRect - 14878,348 [ms]
GdiPlus - FillRound - 20379,553 [ms]
GdiPlus - FillPath - 73833,101 [ms]
GdiPlus - FillPattern - LinearGradient - 12657,842 [ms]
GdiPlus - FillPattern - RadialGradient - not exists
GdiPlus - BlitImage - 11277,788 [ms]

Summary:
Fog        - 76877,331 [ms]
Fog (mt)   - 35765,174 [ms]
GDI+       - 133026,632 [ms]
}}}

==Intel Atom 1.6GHz, 1GB ram, ubuntu 9.04 with kernel 2.6.28-12-netbook==

{{{
TODO: Need to run with new benchmark tool

Fog - FillRect - 12658,127 [ms]
Fog - FillRound - 18787,400 [ms]
Fog - FillPath - 103106,142 [ms]
Fog - FillPattern - LinearGradient - 15869,401 [ms]
Fog - FillPattern - RadialGradient - 47146,874 [ms]
Fog - BlitImage - 40,538 [ms]

Fog - FillRect (mt) - 8551,343 [ms]
Fog - FillRound (mt) - 13962,991 [ms]
Fog - FillPath (mt) - 72015,344 [ms]
Fog - FillPattern - LinearGradient (mt) - 11309,438 [ms]
Fog - FillPattern - RadialGradient (mt) - 26251,356 [ms]
Fog - BlitImage (mt) - 40,481 [ms]

Cairo - FillRect - 13785,254 [ms]
Cairo - FillRound - 51748,939 [ms]
Cairo - FillPath - 209477,418 [ms]
Cairo - FillPattern - LinearGradient - 126619,762 [ms]
Cairo - FillPattern - RadialGradient - 451731,319 [ms]
Cairo - BlitImage - 398,907 [ms]

Summary:
Fog        - 197608,482 [ms]
Fog (mt)   - 132130,953 [ms]
Cairo      - 853761,599 [ms]
}}}

=Conclusion=

You can see that Fog library is really fast compared to others. Currently operations like FillRect are really optimized and are tagged as complete. But there are areas where future work will be focused, and this is mainly improving path rasterization. Currently Fog library can be improved by introducing painter object pooling and better memory management.

Another interesting topic is linear and radial gradient fills compared to Cairo. Fog library is able to fill gradients nearly in time needed to fill rect with constant color. This means that these fills can't be optimized to perform better. The radial gradient fill is currently optimized in SSE2 and it's about 4x faster than comparable C optimized code that is about 4x faster than unoptimized code seen in other libraries (for example AntiGrain or Cairo) where is usually called function to calculate pixel (calling functions in heavy inner loops degrades performance a lot).