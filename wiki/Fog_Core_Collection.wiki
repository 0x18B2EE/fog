#summary Fog-Core - Collection
#labels Phase-Implementation

=Fog-Core - Collections=

This section applies to Fog-Framework containers, including collections (Fog/Core/Collection), tools (Fog/Core/Tools) and all other container-based classes (Fog/G2d/Geometry). The base API for all containers should be similar, although it is possible to have differences caused by use-cases of specialized containers.

==Shared Containers==

Container using implicit data sharing and COW (copy-on-wrote) technique. These containers are intended for general use. They can be weak-copied (it's possible to return an instance from a function), modified (using copy-on-write technique), and swapped (using `swap<>`).

List of shared containers:

  * `ColorStopList`,
  * `FileInfo`,
  * `FileMapping`,
  * `Font`,
  * `Hash<KeyT, ItemT>`,
  * `Image`,
  * `ImageConverter`,
  * `ImageFilter`,
  * `ImagePalette`,
  * `List<ItemT>`,
  * `Locale`,
  * `ManagedStringW`,
  * `Map<KeyT, ItemT>`,
  * `MatrixF`,
  * `MatrixD`,
  * `PathF`,
  * `PathD`,
  * `Pattern`,
  * `RegExpA`,
  * `RegExpW`,
  * `Region`,
  * `StringA`,
  * `StringW`,
  * `TextCodec`,
  * `Var`.

==Owned Containers==

Container which has only one owner and it's never implicitly shared between another instance - for example a class member which is never returned, copied or modified outside of the class. The reason why these containers exist is performance and the fact that these containers are always mutable by design.

List of owned containers:

  * `MemBuffer`

==Standard Methods==

Memory-Management (`Shared`):

  <b>`size_t getReference() const`</b> - Get reference count of the shared data. The return value is never zero.

  <b>`bool isDetached() const`</b> -  Get whether the container data is detached (not shared between another container). Note, isDetached() returns `true` when `getReference() == 1` in most cases, however, some classes which allow to adopt read-only data (for example `Image`) can return `false` is such case, informing user that the data is not ready for modification.

  <b>`err_t detach()`</b> - Detach container data, making them available for modification. For performance reasons the `err_t detach()` method is usually inline method which calls `err_t _detach()` in case that the container is not already detached (`isDetached()` returns false). It's not guaranteed that capacity of detached container will be the same as before `detach()` was called. In fact, it's always shrink. Detach is primarily designed to modify the existing content, not to prepare container for adding new items.

Memory-Management (`Any`):

  <b>`size_t getCapacity() const`</b> - Get the container capacity (pre-allocated space for container items). This method is omitted by containers which use fixed-length array to store items (for example `Palette`).
  
  <b>`size_t getLength() const`</b> - Get the container length (count of items in use).
  
  <b>`bool isEmpty() const`</b> - Get whether the container is empty, equivalent to `getLength() == 0`.

  <b>`err_t reserve(size_t min)`</b> - Detach the container data and reserve the capacity to, at least, `min` items. Notice that `reserve()` ensures that container is detached, even if the `min` argument is zero.

  <b>`err_t resize(size_t len)`</b> - Detach the container data and resize the container to `len` items, creating space for these items, but not initializing them. Notice that this method can be dangerous, thus it's not used by all containers.

  <b>`void squeeze()`</b> - Try to make container data more compact. Should be called after container was created or modified; and it isn't expected that the content will be modified in near time.

Item-Management (`Any`):
  
  <b>`void clear()`</b> - Clear all elements in the container, keeping the allocated data if detached.

  <b>`void reset()`</b> - Reset all elements and free reserved memory.

  The difference between `clear()` and `reset()` is that `reset()` frees all memory associated with the container. This means that `clear()` should be used in case that container will be reused, otherwise the `reset()` is preferred. The `reset()` is internally similar to container destructor, except the container is not destroyed, but set to the construction state.

  <b>`ItemT* _prepare(uint32_t cntOp, size_t length)`</b> - Used to reserve space for items being added to the container. The operation is defined by cntOp which can be `CONTAINER_OP_REPLACE` to replace the content of the container or `CONTAINER_OP_APPEND` to append a content at the end of the container. In case that `CONTAINER_OP_REPLACE` is used the behavior should be identical to `ElementT* _add(size_t length)` method.

  <b>`ItemT* _add(size_t length)`</b> - Used to reserve space for items being added to the container. This method can return index instead of `ElementT*` in case that there are more arrays stored in the container (for example `PathF` and `PathD` containers).

  Note that `_prepare()` or `_add()` methods can fail. In such case the `NULL` pointer is returned. The caller is responsible to catch the error and propagate it as `ERR_RT_OUT_OF_MEMORY`. When succeeded, the container length has been modified.

  Please see the example which demonstrates the behavior of containers on ``StringW`` class:

  {{{
  // The initial length of newly created String instance is always zero.
  StringW string;
  
  // Using _prepare() with CONTAINER_OP_REPLACE, the length is set to 3,
  // but characters are not initialized (they might contain garbage).
  CharW* p;

  p = string._prepare(CONTAINER_OP_REPLACE, 3);
  if (FOG_IS_NULL(p)) { /* Handle the error condition. */ }

  p[0] = CharW('F');
  p[1] = CharW('o');
  p[2] = CharW('g');

  // To append another data the _prepare() with CONTAINER_OP_APPEND
  // or _add() methods can be used. The function increases the length
  // of string by 8 characters to 11.
  p = string._add(8);
  if (FOG_IS_NULL(p)) { /* Handle the error condition. */ }

  p[0] = CharW(':');
  p[1] = CharW(':');
  p[2] = CharW('S');
  p[3] = CharW('t');
  p[4] = CharW('r');
  p[5] = CharW('i');
  p[6] = CharW('n');
  p[7] = CharW('g');

  // Now it's highly probable that the capacity of string is larger 
  // than 11 characters. When methods like _add() are called, the
  // container always reserves more space for data to prevent frequent
  // memory reallocation. If the string will not be modified in the 
  // near future then it's safe to compact it using squeeze() method.
  //
  // NOTE: The squeeze() method never fails.
  string.squeeze();
  }}}

  Please note that this example can be rewritten into few lines of code. It's here only to show the design of collection classes inside the Fog-Framework.